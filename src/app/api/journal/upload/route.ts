import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { uploadFile, getFileTypeFromMime } from '@/lib/storage/supabase-storage';
import { z } from 'zod';

// Rate limiting (simple in-memory implementation)
const uploadAttempts = new Map<string, { count: number; resetTime: number }>();
const UPLOAD_LIMIT = 10; // 10 uploads per hour per user
const RATE_LIMIT_WINDOW = 60 * 60 * 1000; // 1 hour

function checkRateLimit(userId: string): boolean {
  const now = Date.now();
  const userAttempts = uploadAttempts.get(userId);

  if (!userAttempts || now > userAttempts.resetTime) {
    uploadAttempts.set(userId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });
    return true;
  }

  if (userAttempts.count >= UPLOAD_LIMIT) {
    return false;
  }

  userAttempts.count++;
  return true;
}

// Validation schema
const uploadQuerySchema = z.object({
  entryId: z.string().min(1, 'Entry ID is required'),
  fileType: z.enum(['voice', 'image']).optional()
});

// POST: Upload voice recordings and images to Supabase
export async function POST(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check rate limit
    if (!checkRateLimit(session.userId)) {
      return NextResponse.json(
        { error: 'Upload limit exceeded. Please try again later.' },
        { status: 429 }
      );
    }

    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const params = uploadQuerySchema.parse({
      entryId: searchParams.get('entryId'),
      fileType: searchParams.get('fileType')
    });

    // Check if journal entry exists and belongs to user
    const journalEntry = await prisma.journalEntry.findFirst({
      where: {
        id: params.entryId,
        userId: session.userId
      }
    });

    if (!journalEntry) {
      return NextResponse.json(
        { error: 'Journal entry not found' },
        { status: 404 }
      );
    }

    // Parse form data
    const formData = await request.formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }

    // Validate file type and size
    const allowedImageTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/gif'];
    const allowedAudioTypes = ['audio/webm', 'audio/mp4', 'audio/wav', 'audio/mpeg', 'audio/ogg'];
    const maxFileSize = 5 * 1024 * 1024; // 5MB

    if (file.size > maxFileSize) {
      return NextResponse.json(
        { error: `File size exceeds 5MB limit` },
        { status: 400 }
      );
    }

    const isValidImage = allowedImageTypes.includes(file.type);
    const isValidAudio = allowedAudioTypes.includes(file.type);

    if (!isValidImage && !isValidAudio) {
      return NextResponse.json(
        { error: `Unsupported file type: ${file.type}` },
        { status: 400 }
      );
    }

    // Upload to Supabase
    const uploadResult = await uploadFile({
      userId: session.userId,
      entryId: params.entryId,
      file
    });

    if (!uploadResult.success) {
      return NextResponse.json(
        { error: uploadResult.error || 'Upload failed' },
        { status: 500 }
      );
    }

    // Get additional metadata for audio files
    let duration: number | undefined;
    let transcript: string | undefined;

    if (isValidAudio) {
      // In a real implementation, you might use a service like:
      // - Web Audio API to get duration client-side
      // - Speech-to-text service for transcription
      // For now, we'll use placeholder values
      duration = 0; // Would be calculated from audio file
      transcript = undefined; // Would be generated by speech-to-text
    }

    // Save file metadata to database
    const fileRecord = await prisma.journalFile.create({
      data: {
        journalEntryId: params.entryId,
        fileName: file.name,
        fileType: getFileTypeFromMime(file.type),
        mimeType: file.type,
        fileSize: BigInt(file.size),
        storageUrl: uploadResult.url!,
        duration,
        transcript
      }
    });

    // Return file metadata
    return NextResponse.json({
      success: true,
      file: {
        id: fileRecord.id,
        fileName: fileRecord.fileName,
        fileType: fileRecord.fileType,
        mimeType: fileRecord.mimeType,
        fileSize: Number(fileRecord.fileSize),
        storageUrl: fileRecord.storageUrl,
        duration: fileRecord.duration,
        transcript: fileRecord.transcript,
        uploadedAt: fileRecord.uploadedAt
      }
    }, { status: 201 });

  } catch (error) {
    console.error('POST /api/journal/upload error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid parameters', details: error.errors },
        { status: 400 }
      );
    }

    // Check for specific error types
    if (error instanceof Error) {
      if (error.message.includes('storage')) {
        return NextResponse.json(
          { error: 'Storage service unavailable' },
          { status: 503 }
        );
      }
      
      if (error.message.includes('network')) {
        return NextResponse.json(
          { error: 'Network error during upload' },
          { status: 502 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// DELETE: Remove uploaded file
export async function DELETE(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const fileId = searchParams.get('fileId');

    if (!fileId) {
      return NextResponse.json(
        { error: 'File ID is required' },
        { status: 400 }
      );
    }

    // Find file and check ownership through journal entry
    const fileRecord = await prisma.journalFile.findFirst({
      where: {
        id: fileId,
        journalEntry: {
          userId: session.userId
        }
      },
      include: {
        journalEntry: true
      }
    });

    if (!fileRecord) {
      return NextResponse.json(
        { error: 'File not found' },
        { status: 404 }
      );
    }

    // Delete from storage
    // Note: In a real implementation, you would delete from Supabase storage
    // const deleteResult = await deleteFile(fileRecord.storageUrl);
    console.log('Would delete file from storage:', fileRecord.fileName);

    // Delete from database
    await prisma.journalFile.delete({
      where: {
        id: fileId
      }
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('DELETE /api/journal/upload error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// GET: Get upload status or file metadata
export async function GET(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const entryId = searchParams.get('entryId');

    if (!entryId) {
      return NextResponse.json(
        { error: 'Entry ID is required' },
        { status: 400 }
      );
    }

    // Get all files for the journal entry
    const files = await prisma.journalFile.findMany({
      where: {
        journalEntryId: entryId,
        journalEntry: {
          userId: session.userId
        }
      },
      orderBy: {
        uploadedAt: 'desc'
      }
    });

    // Transform BigInt to number for JSON serialization
    const transformedFiles = files.map(file => ({
      ...file,
      fileSize: Number(file.fileSize)
    }));

    return NextResponse.json({ files: transformedFiles });

  } catch (error) {
    console.error('GET /api/journal/upload error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}